# Open-Closed Design Principle enabled using Interfaces/Polymorphism
The Open-Closed Principle is one of the key principles of software design that emphasizes the importance of designing software modules that are open for extension but closed for modification. Essentially, the Open-Closed Principle states that software entities should be open for extension, allowing new behavior to be added, but closed for modification, meaning that existing code should not be modified to accommodate changes. This principle promotes code maintainability, reusability, and the minimization of unintended side effects.

Usage of OCP pattern is to build systems that are more maintainable, flexible and scalable. OCP helps to avoid making changes in existing well-tested code, reducing the risk of introducing bugs and issues while developing.

In our example code (without using OCP pattern), the ProcessPayment() function has a switch statement that checks the payment type and performs different logic based on the payment type. This violates the Open-Closed Principle because if a new payment type is introduced, the ProcessPayment() function needs to be modified to handle the new type.

In the refactored code, we have introduced the Payment interface, which defines the Process() method. The PaymentProcessor struct and its ProcessPayment() method handle the processing of payments by accepting any type that satisfies the Payment interface. The CreditCardPayment and BankTransferPayment structs implement the Payment interface by providing their respective Process() methods. The refactored code demonstates how to add a new "PayPal" payment method cleanly/seamlessly without making any changes to the existing codebase.

This allows the code to be open for extension, as new payment types can be added by implementing the Payment interface without modifying the existing code. By applying the Open-Closed Principle, we have decoupled the payment processing logic from the specific payment types. The PaymentProcessor class can process any payment type that implements the Payment interface, allowing for easy extension and scalability without modifying existing code.

By embracing the Open-Closed Principle, we are able to create software that is more maintainable, reusable, scalable, testable, and collaborative. It promotes modular design, reduces the risk of introducing bugs, and allows for easy adaptation to changing requirements. Applying the Open-Closed Principle, leads to well-designed, robust, and flexible codebases.

To apply the Open-Closed Principle effectively, specifically in Go, following are the key guidelines:
-  **Identify Areas of Variation**: Identify the aspects of your codebase that are likely to change or require extension in the future. These could be new functionalities, different algorithms, or variations in behavior based on specific conditions or requirements. Understanding these areas of potential change is crucial for designing code that is open for extension.
-  **Encapsulate Variation with Interfaces**: In Go, interfaces play a significant role in achieving the Open-Closed Principle. Define interfaces that represent the behavior or capabilities that your code should provide. By coding to interfaces rather than concrete implementations, you decouple the code from specific implementations and make it easier to extend and modify behavior without changing existing code.
-  **Implement Behavior Through Interfaces/Polymorphism**: Implementations of interfaces represent the specific behaviors or variations that your code should exhibit. By defining different implementations of the same interface (Polymorphism), you can introduce new behavior without modifying existing code. This approach allows for easy extensibility and reusability, as new implementations can be added without impacting the existing codebase.