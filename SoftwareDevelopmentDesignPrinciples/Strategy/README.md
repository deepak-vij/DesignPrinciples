# Strategy
**Strategy** pattern is a behavioral design pattern. Strategy pattern allows changing the behavior of an object at the runtime which is useful in certain cases. “The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.”

See the companion [code example](/SoftwareDevelopmentDesignPrinciples/Strategy). In this example, suppose we have a toy that recites the dialogues of superheroes. Users can select a superhero by pressing a button of the toy. When the play button is pressed on the toy, it recites the dialogue of the superhero and as the user changes the superhero on the toy it recites the dialogue for that superhero. One can notice how the dialogue recite behavior (of the toy) is changing while playing by pressing buttons. This is what the Strategy Pattern achieves.

The behavior of the toy object in our example is coming from an interface, DialogueReciter. And the actual implementation of the behavior, Recite, is done separately by different concrete types e.g. SpiderMan , SuperMan , and BatMan . Had the toy behavior been coded to the concrete type, we would be locked to use only that specific behavior. The key observation is that — **Program to an interface, not an implementation** and it is an important design principle.

Key idea is that “Identify the aspects of the application that vary and separate them from what stays the same.” In our companion code example, this is exactly what we have done! We knew that the behavior of the toy is going to change and hence we want toy to encapsulate so that later we can modify or extend this varying part without affecting those that do not. The strategy pattern will enable dynamic behavior changes without affecting other parts of the application.